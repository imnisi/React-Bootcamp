# -----------------------------useState Hook-----------------------------

* useState Hook is a special function that takes the initial state as an argument and returns an array of two entries. The first entry is the current state, and the second is a function that updates the state.

Syntax: const [state, setState] = useState(initialState);

? const [car, setCar] = useState({
?    brand: "Ferrari",
?    model: "Roma",
?    year: "2023",
?    color: "Red",
?  });

?  return (
?    <>
?      <h1>Understanding useState Hook!</h1>
?      <h2>My {car.brand}</h2>
?      <p>
?        <b>
?          It is a {car.color} {car.model} from {car.year}
?        </b>
?      </p>
!     <button
!        onClick={() => {
!          setCar(({ car }) => {
!            car.color = "Blue";
!          });
!        }}
!      >
?        Change Color
?      </button>
?    </>
?  );

* On clicking on blue button ,it is not working, can you explain me in hinglish


# Tumhara current code:

```jsx
? onClick={() => {
?  setCar(({ car }) => {
?    car.color = "Blue";
?  });
? }}
```

# Isme dikkat ye hai ki:

* 1. Tumne galat tarike se function likha hai.
!   `setCar` ka callback parameter directly purana state (car) hota hai,
!   na ki `{ car }` object ke andar wrapped.
!   Tumne likha hai `({ car })`, matlab destructuring kar rahe ho —
!   lekin state object ka naam hi `car` hai, uske andar `car` property nahi hai.

* 2. Dusri galti:
!   `setCar` se tumhe naya object return karna hota hai.
!   Tum sirf `car.color = "Blue"` likh rahe ho, par kuch return nahi kar rahe.
!   React state immutable hoti hai — iska matlab, directly change nahi karna chahiye,
!   balki ek naya object banake `setCar` ko dena hota hai.

---

# Sahi code:

```jsx
? <button
?  onClick={() => {
?    setCar((prevCar) => ({
?      ...prevCar,      // purani properties ko rakh lo
?      color: "Blue",   // bas color ko update kar do
?    }));
?  }}
? >
?  Change Color
? </button>
```

# Hinglish Explanation:

React me `useState` ka kaam hai ek state variable aur usko change karne wala function dena.
Tumhare case me:

? `car` — current value hai,
? `setCar` — usko update karne wala function hai.

! Jab tum `setCar` call karte ho, React expect karta hai ki tum naya object doge.
! Par tumne purane object (`car`) ko directly modify kar diya —
! React isse detect nahi kar paata, isliye UI re-render nahi hoti.

# Isliye hum likhte hain:

```js
! setCar((prevCar) => ({ ...prevCar, color: "Blue" }))
```

# Meaning:

* `prevCar` → purani car state le lo
* `{ ...prevCar }` → uska ek copy banao
* `color: "Blue"` → naya color overwrite kar do

! React dekhta hai ki ek naya object aaya hai → fir wo component re-render karta hai.

# Agar chaho to aur simple version bhi likh sakte ho:

```jsx
? <button onClick={() => setCar({ ...car, color: "Blue" })}>
?  Change Color
? </button>
```

# -----------------------------useEffect Hook-----------------------------

* useEffect Hook is used to perform side effects in functional components. It takes two arguments: a function that contains the side-effect logic, and an optional array of dependencies that determine when the effect should re-run.

* Side effects can include data fetching, subscriptions, or manually changing the DOM.

* If the dependency array is empty, the effect will only run once after the initial render.

Syntax: useEffect(() => {
  Side-effect logic here
}, [dependencies]); 


# When we use useEffect() hook without any dependency, then it will execute the callback function, whenever any state change in the component, and also after the initial render.

* To kya ye entire component ko fir bhi re-render krega agr callback function ke andar ka code state change na kr raha ho? I mean, agr hum callback function ke andar sirf console.log() kr rhe ho, to kya fir bhi component re-render hoga? 

! Nahi, agar callback function ke andar koi state change nahi ho raha hai, to component re-render nahi hoga. useEffect hook sirf side effects ko handle karta hai, aur agar uske andar koi state update nahi ho raha hai, to component re-render nahi hota.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  });

# When we use useEffect() hook with an empty dependency array, then it will execute the callback function only once after the initial render.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, []);

# When we use useEffect() hook with a dependency array having some state variables, then it will execute the callback function only when any of the state variable in the dependency array changes.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, [count]);

# Example:

? import { useState, useEffect } from "react";
? const [count, setCount] = useState(0);
? useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, []);
? return (
?   <>
?     <h1>Count: {count}</h1>
?   </>
? );

# Explanation:

* In this example, we have a state variable `count` initialized to 0.

* We use the `useEffect` hook with an empty dependency array, so the effect runs only once after the initial render.
* Inside the effect, we set a timeout to increment the `count` state by 1 after 5 seconds.

* As a result, the count will update to 1 after 5 seconds, and the component will re-render to display the updated count.

* If we had used `useEffect` without an empty dependency array, the effect would run after every render, causing the count to increment continuously every 5 seconds.

* If we had used `useEffect` with `[count]` as the dependency array, the effect would run only when the `count` state changes, which would also lead to continuous increments every 5 seconds after the initial render.

# StrictMode causes useEffect to run twice in development mode due to which the first start counting from 0 to 2 instead of 1.

? <StrictMode>
?    <UseEffectHook />
? </StrictMode>

? const [value, setValue] = useState(0);
? const [count, setCount] = useState(0);

? useEffect(() => {
?    setCount((prevCount) => prevCount + 1);
? });

! So, the above code will cause infinite loop because every time the component re-renders, the useEffect will run   and update the state, causing another re-render. This cycle continues indefinitely.

! Because at first when useState() is called, it initializes count to 0. Then, when the component renders for the first time, useEffect runs and updates count to 1. This causes the component to re-render, and useEffect runs again, updating count to 2. This cycle continues indefinitely, causing an infinite loop of re-renders.
 
* So, to avoid this infinite loop, we can use useRef hook, jo ki component ke re-render hone par apne value ko maintain krta hai bina component ko re-render kiye.

# useEffect() ko kaise pata chl rha hai ki component re-render hua hai?
 Kyuki useEffect hook har render ke baad chalta hai. Jab bhi component re-render hota hai, useEffect ka callback function execute hota hai. Isliye, jab bhi hum state update karte hain aur component re-render hota hai, useEffect ka callback function fir se chalta hai.

# Kya useEffect() hook har baar chlta hai jab bhi component re-render hota hai, chahe hum state update kare ya na kare?
 Yes, useEffect hook runs after every render of the component, regardless of whether the state has changed or not. It is executed after the component has been rendered to the DOM.

# Aur ye tab bhi chlta hai Jab hum state update na kare, mtlb agr hum useEffect ke andar sirf console.log() kr rhe ho to kya fir bhi ye chlta hai? 

 Yes, useEffect will still run after every render, even if there are no state updates. It is designed to handle side effects in functional components, and it runs after the component has been rendered to the DOM. So, if you have a console.log() statement inside useEffect, it will execute every time the component re-renders, regardless of whether any state has changed or not.

! In short: Chahe hum state update kare ya na kare, useEffect hook har baar chalta hai jab bhi component re-render hota hai chahe ye rendering kisi aur wajah se ho.

# When an infinite loop occurs due to useEffect, and when not occur? How to avoid an infinite loop in using useEffect?

 An infinite loop occurs in useEffect when the effect updates a state that is also listed in its dependency array, causing the effect to run again and again.

# Pehle samjho: `useEffect` kab run hota hai?

`useEffect(() => { ... }, [dependencies])`

* 1st argument: Ek callback function hota hai — yahan likha code tab chalega jab React component render hota hai.
* 2nd argument (dependencies array): decide karta hai kab dobara run hona hai.

# Infinite loop kab hota hai?

Infinite loop tab hota hai jab:

1. Tum `useEffect` ke andar state update karte ho (`setState`)
2. Aur wo state dependency array mein likhi hoti hai

# Example:

```jsx
? useEffect(() => {
?  setCount(count + 1);
? }, [count]);
```

# Yahaan kya ho raha hai:

* Component render hua → effect chala → `setCount` ne state badli
* State badli → component re-render → effect phir se chala
* Effect ne phir se state badli → again re-render → again effect

! Result = Infinite loop

---

# Jab Infinite loop nahi hota

*1. Jab dependency array empty hai:

   ```jsx
?   useEffect(() => {
?     console.log("Runs only once");
?   }, []);  // Ye sirf component mount par ek hi baar chalega.
```

 

* 2. Jab dependency array mein wo value nahi likhi hoti jise effect ke andar update kiya ja raha hai:

   ```jsx
?   useEffect(() => {
?     setData(fetchData());
?   }, []); // data yahan dependency mein nahi hai
   ```
Ye sirf ek hi baar chalega, infinite loop nahi hoga.

* 3. Jab state update **condition ke sath** hoti hai:

   ```jsx
?   useEffect(() => {
?     if (count < 5) {
?       setCount(count + 1);
?     }
?   }, [count]);
   ```
 Ye sirf 5 tak chalega, infinite nahi.


# Infinite loop ko avoid karne ke tarike

* 1. Sahi dependencies likho
   → Sirf wahi values likho jo truly necessary hain.

* 2. Conditional updates karo

   ```jsx
?   useEffect(() => {
?     if (!dataLoaded) {
?       fetchData();
?       setDataLoaded(true);
?     }
?   }, [dataLoaded]);
   ```

* 3. Functional update use karo
   Jab tumhe purani state ki value chahiye:

```jsx
?   useEffect(() => {
?     setCount(prev => prev + 1);
?   }, []); // Dependency array [] ka matlab hai: ye useEffect sirf ek baar chalega (jab component mount hota hai).
   ```

* 4. Data fetching ke liye dependency hatao
   Kyunki API call sirf mount ke time par hi chahiye hoti hai:

   ```jsx
?   useEffect(() => {
?     fetchData();
?   }, []); // Empty array means: run only once
   ```

---

# Summary Table:

| Situation                                        | Loop hota hai? | Explanation                 |
| ------------------------------------------------ | -------------- | --------------------------- |
| `setState` inside useEffect & that state in deps |   Yes          | Keeps triggering re-renders |
| Empty dependency `[]`                            |   No           | Runs only once              |
| Conditional state update                         |   Maybe        | Runs till condition false   |
| State update not in deps                         |   No           | No dependency change        |


# So, to avoid this infinite loop, we can use useRef hook, jo ki component ke re-render hone par apne value ko maintain krta hai bina component ko re-render kiye.


# -----------------------------useRef Hook-----------------------------

* useRef Hook is used to create a mutable reference that persists across re-renders of a functional component. It can be used to access and manipulate DOM elements directly, store mutable values, or keep track of previous state values without causing re-renders.

Syntax: const refContainer = useRef(initialValue);

In simple word, useRef hooks ka use krke jis bhi variable ko hum define krte hai wo variable mutable in nature hota hai aur component ke re-render hone par bhi apni value ko maintain krta hai. Aur jab bhi variables ki value change hoti to component re-render nhi hota hai.

Iske alawa, useRef ka use hum kisi bhi DOM element ko directly access krne ke liye krte hai.

* Example 1: Accessing DOM elements

? import { useRef } from "react";
? const inputRef = useRef(null);
? return (  
?   <>
?     <input type="text" ref={inputRef} />
?     <button onClick={() => inputRef.current.focus()}>Focus Input</button> 
?   </>
? );

# Explanation:
? In this example, we create a reference using useRef and attach it to an input element. When the button is clicked, we use the reference to focus the input field directly.




* Example 2: Storing mutable values

? import { useRef, useState } from "react";
? const renderCount = useRef(0);
? const [count, setCount] = useState(0);
? renderCount.current += 1;
? return (
?   <>
?     <h1>Count: {count}</h1>
?     <h2>Render Count: {renderCount.current}</h2>
?     <button onClick={() => setCount(count + 1)}>Increment Count</button>
?   </>
? );
# Explanation:
? In this example, we use useRef to keep track of the number of times the component has rendered. The renderCount variable is mutable and persists across re-renders without causing additional renders when it changes.