# -----------------------------useEffect Hook-----------------------------

* useEffect Hook is used to perform side effects in functional components. It takes two arguments: a function that contains the side-effect logic, and an optional array of dependencies that determine when the effect should re-run.

* Side effects can include data fetching, subscriptions, or manually changing the DOM.

* If the dependency array is empty, the effect will only run once after the initial render.

Syntax: useEffect(() => {
  Side-effect logic here
}, [dependencies]); 


# When we use useEffect() hook without any dependency, then it will execute the callback function, whenever any state change in the component, and also after the initial render.

* To kya ye entire component ko fir bhi re-render krega agr callback function ke andar ka code state change na kr raha ho? I mean, agr hum callback function ke andar sirf console.log() kr rhe ho, to kya fir bhi component re-render hoga? 

! Nahi, agar callback function ke andar koi state change nahi ho raha hai, to component re-render nahi hoga. useEffect hook sirf side effects ko handle karta hai, aur agar uske andar koi state update nahi ho raha hai, to component re-render nahi hota.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  });

# When we use useEffect() hook with an empty dependency array, then it will execute the callback function only once after the initial render.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, []);

# When we use useEffect() hook with a dependency array having some state variables, then it will execute the callback function only when any of the state variable in the dependency array changes.

?  useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, [count]);

# Example:

? import { useState, useEffect } from "react";
? const [count, setCount] = useState(0);
? useEffect(() => {
?    setTimeout(() => {
?      setCount((prev) => prev + 1);
?    }, 5000);
?  }, []);
? return (
?   <>
?     <h1>Count: {count}</h1>
?   </>
? );

# Explanation:

* In this example, we have a state variable `count` initialized to 0.

* We use the `useEffect` hook with an empty dependency array, so the effect runs only once after the initial render.
* Inside the effect, we set a timeout to increment the `count` state by 1 after 5 seconds.

* As a result, the count will update to 1 after 5 seconds, and the component will re-render to display the updated count.

* If we had used `useEffect` without an empty dependency array, the effect would run after every render, causing the count to increment continuously every 5 seconds.

* If we had used `useEffect` with `[count]` as the dependency array, the effect would run only when the `count` state changes, which would also lead to continuous increments every 5 seconds after the initial render.

# StrictMode causes useEffect to run twice in development mode due to which the first start counting from 0 to 2 instead of 1.

? <StrictMode>
?    <UseEffectHook />
? </StrictMode>

? const [value, setValue] = useState(0);
? const [count, setCount] = useState(0);

? useEffect(() => {
?    setCount((prevCount) => prevCount + 1);
? });

! So, the above code will cause infinite loop because every time the component re-renders, the useEffect will run   and update the state, causing another re-render. This cycle continues indefinitely.

! Because at first when useState() is called, it initializes count to 0. Then, when the component renders for the first time, useEffect runs and updates count to 1. This causes the component to re-render, and useEffect runs again, updating count to 2. This cycle continues indefinitely, causing an infinite loop of re-renders.
 
* So, to avoid this infinite loop, we can use useRef hook, jo ki component ke re-render hone par apne value ko maintain krta hai bina component ko re-render kiye.

# useEffect() ko kaise pata chl rha hai ki component re-render hua hai?
 Kyuki useEffect hook har render ke baad chalta hai. Jab bhi component re-render hota hai, useEffect ka callback function execute hota hai. Isliye, jab bhi hum state update karte hain aur component re-render hota hai, useEffect ka callback function fir se chalta hai.

# Component me kisi wajh se bhi component render hota ya re-render hai to useEffect chalta hai ya nahi


* useEffect chalega ya nahi - ye depend karta hai dependency array par:

# 3 Cases hain:

# 1.Dependency array nahi diya (empty bhi nahi)
```javascript
? useEffect(() => {
?  console.log("Har re-render pe chalega!");
? });
```
✅ Har render/re-render pe chalega - kisi bhi wajah se component render ho

# 2. Empty dependency array `[]`
```javascript
? useEffect(() => {
?   console.log("Sirf pehli baar chalega!");
? }, []);
```
✅ Sirf pehli baar chalega (component mount hone pe) - re-render pe NAHI chalega

# 3. Dependencies diye hain
```javascript
? useEffect(() => {
?  console.log("Count change hua!");
? }, [count]);
```
✅ Tabhi chalega jab `count` change hoga - baaki re-renders pe nahi chalega

# Example:

```javascript
? function MyComponent() {
?  const [count, setCount] = useState(0);
?  const [name, setName] = useState("Raj");

?  useEffect(() => {
?    console.log("Count badla:", count);
?  }, [count]); // Sirf count change pe chalega

 Agar name change karo to ye useEffect NAHI chalega
 Kyunki dependency array me sirf count hai
}
```

* useEffect automatically nahi chalta har re-render pe - dependency array decide karta hai kab chalega!

# When an infinite loop occurs due to useEffect, and when not occur? How to avoid an infinite loop in using useEffect?

 An infinite loop occurs in useEffect when the effect updates a state that is also listed in its dependency array, causing the effect to run again and again.

# Pehle samjho: `useEffect` kab run hota hai?

`useEffect(() => { ... }, [dependencies])`

* 1st argument: Ek callback function hota hai — yahan likha code tab chalega jab React component render hota hai.
* 2nd argument (dependencies array): decide karta hai kab dobara run hona hai.

# Infinite loop kab hota hai?

Infinite loop tab hota hai jab:

1. Tum `useEffect` ke andar state update karte ho (`setState`)
2. Aur wo state dependency array mein likhi hoti hai

# Example:

```jsx
? useEffect(() => {
?  setCount(count + 1);
? }, [count]);
```

# Yahaan kya ho raha hai:

* Component render hua → effect chala → `setCount` ne state badli
* State badli → component re-render → effect phir se chala
* Effect ne phir se state badli → again re-render → again effect

! Result = Infinite loop

---

# Jab Infinite loop nahi hota

*1. Jab dependency array empty hai:

   ```jsx
?   useEffect(() => {
?     console.log("Runs only once");
?   }, []);  // Ye sirf component mount par ek hi baar chalega.
```

 

* 2. Jab dependency array mein wo value nahi likhi hoti jise effect ke andar update kiya ja raha hai:

   ```jsx
?   useEffect(() => {
?     setData(fetchData());
?   }, []); // data yahan dependency mein nahi hai
   ```
Ye sirf ek hi baar chalega, infinite loop nahi hoga.

* 3. Jab state update condition ke sath hoti hai:

   ```jsx
?   useEffect(() => {
?     if (count < 5) {
?       setCount(count + 1);
?     }
?   }, [count]);
   ```
 Ye sirf 5 tak chalega, infinite nahi.


# Infinite loop ko avoid karne ke tarike

* 1. Sahi dependencies likho
   → Sirf wahi values likho jo truly necessary hain.

* 2. Conditional updates karo

   ```jsx
?   useEffect(() => {
?     if (!dataLoaded) {
?       fetchData();
?       setDataLoaded(true);
?     }
?   }, [dataLoaded]);
   ```

* 3. Functional update use karo
   Jab tumhe purani state ki value chahiye:

```jsx
?   useEffect(() => {
?     setCount(prev => prev + 1);
?   }, []); // Dependency array [] ka matlab hai: ye useEffect sirf ek baar chalega (jab component mount hota hai).
   ```

* 4. Data fetching ke liye dependency hatao
   Kyunki API call sirf mount ke time par hi chahiye hoti hai:

   ```jsx
?   useEffect(() => {
?     fetchData();
?   }, []); // Empty array means: run only once
   ```

---

# Summary Table:

| Situation                                        | Loop hota hai? | Explanation                 |
| ------------------------------------------------ | -------------- | --------------------------- |
| `setState` inside useEffect & that state in deps |   Yes          | Keeps triggering re-renders |
| Empty dependency `[]`                            |   No           | Runs only once              |
| Conditional state update                         |   Maybe        | Runs till condition false   |
| State update not in deps                         |   No           | No dependency change        |


# So, to avoid this infinite loop, we can use useRef hook, jo ki component ke re-render hone par apne value ko maintain krta hai bina component ko re-render kiye.

┌─────────────────────────────────────────────────────────┐
│                    COMPONENT RENDER                     │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  1. State/Props change hota hai                         │
│       ↓                                                 │
│  2. Component function execute hota hai                 │
│       ↓                                                 │
│  3. JSX return hota hai                                 │
│       ↓                                                 │
│  4. React Virtual DOM update karta hai                  │
│       ↓                                                 │
│  5. Browser Real DOM paint karta hai (UI updates)       │
│       ↓                                                 │
│  6. useLayoutEffect runs (if any)                       │
│       ↓                                                 │
│  7. useEffect runs (based on dependencies)              │
│       ↓                                                 │
│  [Waiting for next state/props change...]               │
│                                                         │
└─────────────────────────────────────────────────────────┘

| Pattern | Code Example | Kab Chalega? | Explanation |
|-------------|----------------|----------------|----------------|
| Har render | `useEffect(() => {})` | Mount + Every update      | Runs on every render (no dependency array) |
| Sirf mount | `useEffect(() => {}, [])` | Only once on mount | Runs only once when component mounts |
| Specific change | `useEffect(() => {}, [dep])` | Mount + When `dep` changes | Runs initially + every time `dep` value changes |
| With cleanup | `useEffect(() => { return () => {} })` | Cleanup before unmount/next effect | Runs cleanup **before component unmounts** or before next effect |

# Golden Rule:

! useEffect ALWAYS runs AFTER the render is complete!
! (useEffect HAMESHA render/re-render COMPLETE hone ke BAAD chalta hai!)


# Perfect Timeline:

┌──────────────────────────────────────────┐
│ 1. State/Props change                    │
└──────────────────────────────────────────┘
              ↓
┌──────────────────────────────────────────┐
│ 2. Component function runs               │
│    (calculations, JSX creation)          │
└──────────────────────────────────────────┘
              ↓
┌──────────────────────────────────────────┐
│ 3. React updates Virtual DOM             │
└──────────────────────────────────────────┘
              ↓
┌──────────────────────────────────────────┐
│ 4. React updates Real DOM                │
└──────────────────────────────────────────┘
              ↓
┌──────────────────────────────────────────┐
│ 5. Browser PAINTS screen                 │
│    (User ko UI dikhta hai)               │
└──────────────────────────────────────────┘
              ↓
┌──────────────────────────────────────────┐
│ 6. useEffect runs                        │
│    (AFTER everything is done!)           │
└──────────────────────────────────────────┘

# Proof - Console Example:

```
? function Example() {
?  const [count, setCount] = useState(0);

?  console.log("1️⃣ Component rendering, count:", count);

?  useEffect(() => {
?    console.log("3️⃣ useEffect ran, count:", count);
?  });

?  console.log("2️⃣ Before return");

?  return (
?    <div>
?      <h2>Count: {count}</h2>
?      <button onClick={() => setCount(count + 1)}>Increment</button>
?    </div>
?  );
? }
```

* Output jab button click karte ho:**
```
1️⃣ Component rendering, count: 1
2️⃣ Before return
[Browser paints screen - User sees "Count: 1"]
3️⃣ useEffect ran, count: 1
```

! Dekho: useEffect sabse last mein!

---

# Why This Design?

React ne ye deliberately kiya hai:

# 1. Non-blocking UI:
```
? useEffect(() => {
  ! Heavy API call (2 seconds)
?  fetch("https://api.example.com/data")
?    .then(res => res.json())
?    .then(data => setData(data));
? });

! User ko UI pehle dikhta hai, API call background mein hota hai,Page freeze nahi hota!
```

# 2. User sees UI immediately:
```
* Without useEffect after render:
User clicks button → Wait 2 seconds → UI updates (Bad UX!)

* With useEffect after render:
User clicks button → UI updates immediately → Background work (Good UX!)
```

# Key Takeaways:

| Statement                                        | True/False|
|--------------------------------------------------|-----------|
| useEffect render ke BAAD chalta hai              | ✅ TRUE   |
| useEffect render ke PEHLE chalta hai             | ❌ FALSE  |
| useEffect browser paint ke BAAD chalta hai       | ✅ TRUE   |
| useEffect UI update ko block karta hai           | ❌ FALSE  |
| useEffect asynchronous hai                       | ✅ TRUE   |
| useLayoutEffect render ke BAAD but paint ke PEHLE | ✅ TRUE  |

! Pattern: Har baar render → UI update → useEffect ✅

# Final Confirmation:

useEffect HAMESHA component ke render/re-render COMPLETE hone ke BAAD chalta hai!
User ko pehle UI dikhta hai, phir useEffect chalta hai!
Ye React ka intentional design hai for better performance!
